<html>

<head>
<title>Tribal Hero Map Viewer</title>
<meta charset="utf-8"></meta>
<style type="text/css">
  body {
    background-color: #FFE9BF;
  } 
  #map {
    max-width: 1080px;
    height: 720px;
    margin: auto;
    background-color: #BFD481;
    outline-style: solid;
    outline-color: #624221;
  }
  .content {
    max-width: 1080px;
    height: 320px;
    padding: 3px;
    margin: auto;
    color: 624221;
    text-align: left;
  }
  #column1 {
    font: 13px arial, sans-serif;
    float: left;
    width: 300px;
  }
  #column2 {
    font: 18px arial, sans-serif;
    margin-left: auto;
    margin-right: auto;
    width: 240px;
  }
  #column3 {
    text-align: center;
    font: 16px arial, sans-serif;
  }
  #column4 {
    float: right;
  }
</style>
</head>
    
<body>

<div id="map"></div>
<div class = "content">
<p id="column3"> Click a node to calculate distance. </p>
<p id="column1"></p>
<p id="column2"></p>
<p id="column4">

</p>
</div>

<script src="js/sigma.min.js"></script>
<script>
  var client = new XMLHttpRequest();

  client.overrideMimeType("text/javascript");
  client.open('GET', 'http://tribblez.tribalhero.com/map.json', true);
  client.onreadystatechange = function() {
    if (client.readyState === 4) {
      var res = client.responseText;

      var jsonRes = JSON.parse(res, function (k, v) {
          if (k === "barbarian_tribes" || k === "forests") {
            return undefined;
          }
          return v;
      });

      var sig = new sigma({
        container: 'map',
        settings: {
          defaultLabelColor: '#73675A',
          defaultNodeColor: '#ec5148',
          defaultHoverLabelBGColor: '#FFF1D3',
          labelThreshold: 4.5,
          labelHoverShadowColor:  '#A6BA68',
          font: "helvetica",
          borderSize: 1,
          batchEdgesDrawing: true,
          defaultNodeBorderColor: '#73675A'
        }
      });

      var tribes = [];
      var players = [];
      var playersRev = [];
      var playerTribes = [];
      var tribeColors = [];

      var colorCounter = 0;
      var colors = [
          '#FFB300',
          '#803E75',
          '#FF6800',
          '#A6BDD7',
          '#C10020',
          '#CEA262',
          '#817066',

          '#007D34',
          '#F6768E',
          '#00538A',
          '#FF7A5C',
          '#53377A',
          '#FF8E00',
          '#B32851',
          '#F4C800',
          '#7F180D',
          '#93AA00',
          '#593315',
          '#F13A13'
          ];

      for (i = 0; i < jsonRes.players.length; i++) {
        var pl = jsonRes.players[i];
        players[pl.id] = pl.name;
        playersRev[pl.name] = pl.id;
        if (!pl.tribe_id) continue;
        playerTribes[pl.id] = pl.tribe_id;
      }
      
      var tribe_legend = '';
      
      for (i = 0; i < jsonRes.tribes.length; i++) {
        var tr = jsonRes.tribes[i];
        var id = playerTribes[tr.owner_player_id];
        tribes[id] = tr.name;
        if ((tr.level == 1 && ~~tr.victory_points === 0) || colorCounter == colors.length) continue;
        tribeColors[id] = colors[colorCounter];
        tribe_legend += '<b><font color=\"' + colors[colorCounter] + '\"> ' + tr.name + "</font></b><br>";
        tribe_legend += 'Level: ' + tr.level + ' AP: ' + tr.attack_points + ' DP: ' + tr.defense_points + ' VP: ' + ~~tr.victory_points + '<br>';
        colorCounter++;
      }
      
      document.getElementById("column1").innerHTML = tribe_legend;
      
      for (i = 0; i < jsonRes.cities.length; i++) {
        var city = jsonRes.cities[i];
          sig.graph.addNode({
            id: city.name,
            label: city.name,
            x: city.x,
            y: ~~(city.y * 0.5),
            size: 0.08,
            color: (!playerTribes[city.player_id] || !tribeColors[playerTribes[city.player_id]]) ? '#D6F1BB' : tribeColors[playerTribes[city.player_id]],
            player: players[city.player_id],
            tribe: tribes[playerTribes[city.player_id]],
            long_label: city.name + " - Player: " + players[city.player_id] + " Tribe: " + tribes[playerTribes[city.player_id]],
            group_by: 'player',
            json: city
          });
      }

      for (i = 0; i < jsonRes.strongholds.length; i++) {
        var sh = jsonRes.strongholds[i];
          sig.graph.addNode({
            id: sh.name,
            label: sh.name,
            x: sh.x,
            y: ~~(sh.y * 0.5),
            size: 0.25 * ~~Math.max(1, (sh.level / 6)),
            color: '#FFCC00',
            tribe: tribes[sh.owner_tribe_id],
            long_label: sh.name + " - Level: " + sh.level + " VPR: " + ~~sh.victory_point_rate + " Tribe: " + tribes[sh.owner_tribe_id],
            group_by: 'tribe',
            json: sh
          });
      }
      
      var hover_selected; // The current hover-selected node.
      
      /* Resets the label for the node that was hover selected. */
      function reset_hover_selected() {
        if (!hover_selected) return;
        hover_selected.label = hover_selected.id;
      }
      
      /* Iterates through all nodes and generates edges to the hover-selected node if in same tribe. */
      function add_tribe_edges(root_node) {
        if (!root_node.tribe) return;
        var nodes = sig.graph.nodes();
        for (i = 0; i < nodes.length; i++) {
            var check_node = nodes[i];
            if (check_node.id === root_node.id || check_node.tribe !== root_node.tribe) continue;
            sig.graph.addEdge({
                id: 'e' + i,
                source: check_node.id,
                target: root_node.id
            });
        }
      }
      
      /* Iterates through all nodes and generates edges to the hover-selected node if city owned by same Player. */
      function add_player_edges(root_node) {
        var nodes = sig.graph.nodes();
        for (i = 0; i < nodes.length; i++) {
            var check_node = nodes[i];
            if (check_node.id === root_node.id || check_node.player !== root_node.player) continue;
            sig.graph.addEdge({
                id: 'e' + i,
                source: check_node.id,
                target: root_node.id
            });
        }
      }
	  
      /* Generates a black edge between click_selected and hover_selected. */
	  function add_distance_edge() {
		sig.graph.addEdge({
			id: 'edist',
			source: click_selected.id,
			target: hover_selected.id,
			color: '#232C16'
		});
	  }
	  
      /* Removes all edges from the graph. */
      function reset_all_edges() {
        sig.graph.edges().forEach(function(e) {
            sig.graph.dropEdge(e.id);
        });
      }
      
      function display_hover_info() {
        if (!hover_selected) return;
        var gen = '';
        if (hover_selected.json.date_occupied) gen = generate_stronghold_info(hover_selected);
        else if (hover_selected.json.radius) gen = generate_city_info(hover_selected);
        document.getElementById("column2").innerHTML = gen;
      }
      
      function generate_stronghold_info(s) {
        return ['<b>Stronghold: ' + s.id + '</b>',
                '<br>Level: ' + s.json.level,
                '<br>Tribe: ' + (!s.tribe ? 'None' : s.tribe),
                '<br>VPR: ' + (!s.tribe ? 'N/A' : ~~s.json.victory_point_rate),
                '<br>X: ' + s.x,
                '<br>Y: ' + s.y,
                '<br>Gate Max HP: ' + s.json.gate_max,
                '<br>Days Occupied: ' + (!s.tribe ? 'N/A' : elapsed_days(s.json.date_occupied)),
                ].join('\n');
      }
      
      function generate_city_info(c) {
        return ['<b>City: ' + c.id + '</b>',
                '<br>Player: ' + c.player,
                '<br>Tribe: ' + (!c.tribe ? 'None' : c.tribe),
                '<br>X: ' + c.x,
                '<br>Y: ' + c.y,
                '<br>IP: ' + c.json.value,
                '<br>Expense: ' + c.json.expense_value,
                '<br>Loot Stolen: ' + c.json.loot_stolen,
                '<br>Attack: ' + c.json.attack_points,
                '<br>Defense: ' + c.json.defense_point,
                '<br>Deployed Troops: ' + c.json.troops.length
                ].join('\n');
      }
      
	  /* Takes a Date.toJSON formatted string (e.g. 2012-04-23T18:25:43.511Z) and returns elapsed days. */
      function elapsed_days(date_string) {
        var unix_past = Date.parse(date_string);
        var unix_present = new Date().getTime();
        var diff = unix_present - unix_past;
        var days = (diff / (1000*60*60*24)).toString();
        return days.length > 4 ? days.substr(0, 4) : days;
      }
      
      sig.bind('overNode', function(e) {
        reset_hover_selected();
		hover_selected = e.data.node;
        hover_selected.label = hover_selected.long_label;
		
        if (sig.graph.edges().length !== 0) return;
        if (hover_selected.group_by === 'tribe') add_tribe_edges(hover_selected);
        if (hover_selected.group_by === 'player') add_player_edges(hover_selected);
        if (click_selected && hover_selected != click_selected) show_distance(hover_selected);
		
		display_hover_info();
        sig.refresh();
      });
        
      sig.bind('outNode', function(e) {
        reset_hover_selected();
        reset_all_edges();
        document.getElementById("column2").innerHTML = '';
        sig.refresh();
      });
      
      var click_selected; // The current click-selected node.
      
      /* Binds to Sigma.js event triggered by clicking on a node. */
      sig.bind('clickNode', function(e) {
        click_selected = e.data.node;
		// Update DOM to notify user of clicked node and to hover another node for distance:
        document.getElementById("column3").innerHTML = 
            'Hover over another node to calculate distance. Currently selected: <b>' + click_selected.id + '</b>';
      });
      
      /* Updates DOM to display the distance between click_selected and hover_selected node. */
      function show_distance(n) {
	    add_distance_edge();
        document.getElementById("column3").innerHTML = 
            'Distance from <b>' + click_selected.id + ' </b> to <b>' + n.id + ': ' + calc_distance(click_selected.x, n.x, click_selected.json.y, n.json.y);
      }
      
      /* Returns the distance between two nodes. */
      function calc_distance(x, x1, y, y1) {
        var offset = 0;
           if ((y % 2 == 1 && y1 % 2 == 0 && x1 <= x) ||
               (y % 2 == 0 && y1 % 2 == 1 && x1 >= x))
           {
               offset = 1;
           }
           return ~~((x1 > x ? x1 - x : x - x1) + (y1 > y ? y1 - y : y - y1) / 2 + offset);
      }

      sig.refresh();
    }
  };
  client.send();
</script>
    
</body>

</html>